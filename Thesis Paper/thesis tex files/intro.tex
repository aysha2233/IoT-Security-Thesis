\section{Introduction}
The emergence of the Internet of Things (IoT) has led to many innovations in Smart Home technology. For example, many home owners now manage appliances throughout their home over a network such as the Internet. The increased popularity of such devices has created a market boom for embedded technologies, but unfortunately, due to the limited nature of IoT devices (e.g. low cost, development, and functionality), the security of IoT is also limited. On the other hand, many IoT devices still require similar security guarantees to that of regular end hosts.

A customizable security library implemented in Java could provide needed security functionalities such as key exchange, authentication, encryption, and integrity to a multitude of embedded devices. Java has been a preferred language for many developers around the world since the 1990's due to the platforms robustness, ease of understanding, security, and platform independence. The Java platform is also widely distributed which allows for ease of integration. However, Java has occasionally been criticized as being too computationally heavy, but with recent developments in the Java Micro Edition (Java ME), embedded devices can now utilize Java's distribution. Java ME has low system requirements but still supports major components of the more popular Java Standard Edition (Java SE) platform. The Java ME platform runs on embedded devices with a memory footprint as low as 128 KB RAM and 1 MB ROM making it viable for many IoT devices present in a Smart Home. While SSL is available in Java ME by default, we implemented a new security library that utilizes Bouncy Castle's distributed security library for Java ME. Bouncy Castle's unique implementation allows for future customization.

When two parties wish to communicate over a network securely, they often expect confidentiality, authentication, and integrity to be provided by the system. Public-key cryptography, also known as asymmetric cryptography, uses a mathematically related key pair that consists of a public key used for encryption and a private key used for decryption. Along with the ability to encrypt and decrypt data between two parties, public-key cryptography can be used as a form of authentication and integrity. The ability to reveal the public portion of the key pair while keeping security intact is a major benefit to public key cryptography, but there are also drawbacks. Asymmetric encryption is expensive and slow, whereas it generally proves to be much more efficient to use symmetric cryptography (a single shared secret key) for standard data encryption operations. Symmetric keys can also provide authentication and integrity, similar to asymmetric cryptography. However, symmetric key encryption has its own drawbacks. Most importantly, it is required that two parties share the same symmetric key. This poses the problem of securely transferring a shared key across a network where it may become exposed to eavesdropping. In order to combat the weaknesses of both forms of cryptography, it's typical to take advantage of both asymmetric and symmetric cryptography. Typically, asymmetric cryptography is usually used to security send a pre-generated symmetric key through a key exchange protocol such as Diffie-Hellman. Subsequently, this shared secret encrypts/decrypts data exchanged between the two parties through symmetric key cryptography. Using a combination of asymmetric and symmetric cryptography negates the shortcomings when either scheme is used alone.

This project focuses on keeping additional overhead to a minimum while providing confidentiality, authentication, and integrity. Therefore, we utilized a combination of symmetric and asymmetric cryptography to create a customizable security library implemented in Java. Since Elliptic Curve Cryptography (ECC) currently maintains the best resource usage for asymmetric cryptography, particularly key strength to size ratio, our system utilizes ECC. Though ECC has a wide variety of applications, this project only utilizes the generation of EC key-pairs and a version of the Diffie-Hellman protocol that uses ECC (known as ECDH) to exchange symmetric keys. The EC key-pairs and ECDH are meant to establish a symmetric key in order to leverage the speed advantage of symmetric cryptographyn and provide encryption, authentication, and integrity. A default key size of 128 bits would be used to take advantage of a smaller key size while still maintaining security. The encryption scheme used  is AES-128, and  authentication and integrity are provided by using either the AES Galois Counter Mode or by simply attaching a Message Authentication Code to a message.  

With the recent increase in new embedded devices and development boards, IoT development has become a great way to implement a project cheaply and effiecently. However, even in an IoT environment, many of these products desire secure communication. For example, a webcam at home may not require expensive hardware, but privacy of its data must be protected. Unfortunately, many such developments lack these needed security functionalities. One possible reason for such a pitfall may be that correctly utilizing security functionalities and parameters is a steep learning curve for the average developer. Furthermore, novice cryptographers should avoid developing their own cryptographic functionality or schemes and instead, rely on deployments that have been proven to be securely implemented. 

In our library, we provide easy-to-use, straight forward security functions to provide key exchange, authentication, integrity, and encryption to IoT developers who may not be familiar with embedded security and may sink valuable time trying to understand which algorithms will be best suited for their environment. Bouncy Castle's distribution is verbose and while this may be beneficial to more advanced developers, our library provides the most efficent (while still secure) way to stream line security into a Java project. In an IoT environment, even the most advanced security delevloper will arrive at similar strategies that our library provides. We have filtered through the vast array of algorithms and variables to provide the most efficient and secure functionality based on government standards and proper implementation procedure in a timely mannor for a developer. 

When developing in an IoT environment, security is crucial. Having the ability to access easy to use, efficient functions that provide key exchange, encryption, authentication, and integrity is vital in an environment that is so vulnerable to attack.