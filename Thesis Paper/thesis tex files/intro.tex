\section{Introduction}
The emergence of the Internet of Things (IoT) has led to many innovations in Smart Home technology. For example, many home owners now manage appliances throughout their home over a network such as the Internet. The increased popularity of such devices has led to a market boom for embedded technologies, but unfortunately, due to the limited nature of these devices (e.g. low cost, development, and functionality), the security of these devices is also limited. Now more than ever securing our networks is crucial to both the economy and user privacy.

A customizable security library implemented in Java could bring needed security functionality such as key exchange, authentication, encryption, and integrity checks, to a multitude of embedded devices. Java has been a preferred language for many developers around the world since the 1990's due to the platforms robustness, ease of understanding, security, and platform independence. The Java platform is also widely distributed which allows for ease of integration. However, Java has occasionally been criticized as being too heavy, but with the Java Micro Edition embedded devices have become a target of Java's distribution. Java ME has low system requirements and still supports major components of the more popular Java SE platform. The Java ME platform runs on embedded devices with a memory footprint as low as 128 KB RAM and 1 MB ROM making it viable for many IoT devices that would be present in a Smart Home. While SSL is available in Java ME by default, we implemented a new security library using Bouncy Castle's distributed security library for Java ME seemed worth investigating due to Bouncy Castle's unique implementation that allows for future customization.

While there are a wide range of topics related to system and data security in an IoT environment, this project focused on finding methods for authentication, encryption, key exchange, and message integrity that require fewer resources and computation times compared to standard techniques in order to find better schemes for an IoT environment. 

When two parties  wish to communicate over a network securely, they expect a few key elements to be provided by the system: encryption, authentication, and integrity. Often this requires the two parties to use public key cryptography to exchange keys to provide these features. Asymmetric cryptography, also known as public-key cryptography, uses a mathematically related key pair consisting of a public key used for encryption, and a private key used for decryption. Along with the ability to encrypt and decrypt data between two parties, public-key cryptography can be used as a form of authentication and integrity as well. Benefits to using asymmetric keys include, the ability to reveal the public portion of the key pair while keeping security intact and using public-private key pairs as a form of identification or authentication, but there are drawbacks. Asymmetric encryption is expensive and slow so it generally proves to be more effective to use symmetric cryptography (a single shared secret key) for standard data encryption operations; and using symmetric keys can provide forms of authentication and integrity, similar to asymmetric cryptography. However, symmetric key encryption has its own drawbacks, namely it is required that two parties share the same symmetric key and thus poses the problem of securely transferring a shared key across a network where it may become exposed to eavesdropping. In order to combat the weaknesses of both forms of cryptography it's typical to take advantage of both asymmetric and symmetric cryptography to supplement for each others drawbacks.Therefore asymmetric cryptography is usually used for either encrypting and sending a pre-generated symmetric key, or generating a symmetric key through a key exchange protocol (Diffie-Hellman) and then using this shared secret to encrypt/decrypt data exchanged between the two parties. Using a combination of asymmetric and symmetric cryptography for a given system is beneficial as it negates the shortcomings if either scheme were used alone.

 This project's focus on keeping overhead to a minimum while providing encryption, authentication, and integrity meant the approach of using a combination of symmetric and asymmetric cryptography would be used. Since ECC provided an advantage in terms of resource usage, particularly key strength to size ratio, it seemed ECC should play a role in this system. Though ECC has a wide variety of applications, this project only utilizes the generation of EC key-pairs and a version of the Diffie-Hellman protocol that uses ECC (known as ECDH).This functionality would provide a backbone for later functions that would utilize the secrets generated by ECDH for use as symmetric keys. The EC key-pairs and ECDH are meant to establish a symmetric key for all major operations of encryption, authentication, and integrity, and play no further role, although the functions implemented may prove useful for someone using the library in implementing other forms of ECC. Encryption, authentication, and integrity would use symmetric cryptography to leverage the speed advantage versus asymmetric cryptography. A default key size of 128 bits would be used to take advantage of a smaller key size while maintaining security. The encryption scheme used  AES128 and provided authentication and integrity checks using either the Galois Counter Mode or simply attaching a Message Authentication Code to a message.  When developing in an IoT environment security is crucial. Having the ability to access easy to use, and efficient functions to provide key exchange, encryption, authentication, and integrity is crucial in a world that is so vulnerable to attack. In the next section we will discuss and describe ECDH, AES encryption, Message Authentication Codes, and Galois Counter mode, as well as discuss their importance to our security library.

